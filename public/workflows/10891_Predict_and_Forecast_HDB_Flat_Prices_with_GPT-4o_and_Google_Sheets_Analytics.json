{
  "id": "pep0km4DZl5WamRP",
  "meta": {
    "name": "Predict and Forecast HDB Flat Prices with GPT-4o and Google Sheets Analytics",
    "id": 10891
  },
  "name": "GPT-4o HDB Flat Price Prediction and Forecasting System",
  "tags": [],
  "nodes": [
    {
      "id": "c4200cc9-166c-49c7-ac22-7935a21ac7ff",
      "name": "Monthly Data Collection Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [
        -448,
        288
      ],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "months",
              "triggerAtHour": 2
            }
          ]
        }
      },
      "typeVersion": 1.2
    },
    {
      "id": "1e8ee0eb-53a6-465d-995b-f2b9e9cbdfcf",
      "name": "Workflow Configuration",
      "type": "n8n-nodes-base.set",
      "position": [
        -224,
        288
      ],
      "parameters": {
        "options": {},
        "assignments": {
          "assignments": [
            {
              "id": "id-1",
              "name": "hdbApiBaseUrl",
              "type": "string",
              "value": "https://data.gov.sg/api/action/datastore_search"
            },
            {
              "id": "id-2",
              "name": "currentYear",
              "type": "string",
              "value": "2024"
            },
            {
              "id": "id-3",
              "name": "historicalYear1",
              "type": "string",
              "value": "2023"
            },
            {
              "id": "id-4",
              "name": "historicalYear2",
              "type": "string",
              "value": "2022"
            },
            {
              "id": "id-5",
              "name": "historicalYear3",
              "type": "string",
              "value": "2021"
            },
            {
              "id": "id-6",
              "name": "resourceId",
              "type": "string",
              "value": "<__PLACEHOLDER_VALUE__HDB Resale Flat Prices Resource ID__>"
            }
          ]
        },
        "includeOtherFields": true
      },
      "typeVersion": 3.4
    },
    {
      "id": "71b7ffea-e80f-48b5-bf67-bdb266b89160",
      "name": "Fetch Current Year HDB Data",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        0,
        48
      ],
      "parameters": {
        "url": "={{ $('Workflow Configuration').first().json.hdbApiBaseUrl }}?resource_id={{ $('Workflow Configuration').first().json.resourceId }}&filters={\"month\":\"{{ $('Workflow Configuration').first().json.currentYear }}\"}&limit=10000",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "typeVersion": 4.3
    },
    {
      "id": "0018749a-c44e-48a7-b3ee-524928f1cde2",
      "name": "Fetch Historical Data Year 1",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        0,
        192
      ],
      "parameters": {
        "url": "={{ $('Workflow Configuration').first().json.hdbApiBaseUrl }}?resource_id={{ $('Workflow Configuration').first().json.resourceId }}&filters={\"month\":\"{{ $('Workflow Configuration').first().json.historicalYear1 }}\"}&limit=10000",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "typeVersion": 4.3
    },
    {
      "id": "d794c0df-55be-4e92-9064-ac56f4902e8f",
      "name": "Fetch Historical Data Year 2",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        0,
        384
      ],
      "parameters": {
        "url": "={{ $('Workflow Configuration').first().json.hdbApiBaseUrl }}?resource_id={{ $('Workflow Configuration').first().json.resourceId }}&filters={\"month\":\"{{ $('Workflow Configuration').first().json.historicalYear2 }}\"}&limit=10000",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "typeVersion": 4.3
    },
    {
      "id": "7d012cd6-915e-4959-8e80-9d6d4b595317",
      "name": "Fetch Historical Data Year 3",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        0,
        576
      ],
      "parameters": {
        "url": "={{ $('Workflow Configuration').first().json.hdbApiBaseUrl }}?resource_id={{ $('Workflow Configuration').first().json.resourceId }}&filters={\"month\":\"{{ $('Workflow Configuration').first().json.historicalYear3 }}\"}&limit=10000",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "typeVersion": 4.3
    },
    {
      "id": "dd7428f8-e09f-47de-bad7-6513e2bc239a",
      "name": "Merge All Historical Data",
      "type": "n8n-nodes-base.merge",
      "position": [
        224,
        256
      ],
      "parameters": {
        "numberInputs": 4
      },
      "typeVersion": 3.2
    },
    {
      "id": "a50473f3-52de-4f47-a84a-85324aa00b85",
      "name": "Data Cleaning and Normalization",
      "type": "n8n-nodes-base.code",
      "position": [
        448,
        288
      ],
      "parameters": {
        "jsCode": "// Data Cleaning and Normalization for HDB Resale Data\n// This code processes raw HDB data to ensure quality and consistency\n\nconst items = $input.all();\nconst cleanedData = [];\nconst seenRecords = new Set();\n\n// Helper function to normalize town names\nfunction normalizeTown(town) {\n  if (!town) return null;\n  return town.toString().trim().toUpperCase();\n}\n\n// Helper function to standardize flat types\nfunction standardizeFlatType(flatType) {\n  if (!flatType) return null;\n  const normalized = flatType.toString().trim().toUpperCase();\n  \n  // Standardize common variations\n  const typeMap = {\n    '1 ROOM': '1-ROOM',\n    '2 ROOM': '2-ROOM',\n    '3 ROOM': '3-ROOM',\n    '4 ROOM': '4-ROOM',\n    '5 ROOM': '5-ROOM',\n    'EXECUTIVE': 'EXECUTIVE',\n    'MULTI-GENERATION': 'MULTI-GENERATION',\n    'MULTI GENERATION': 'MULTI-GENERATION'\n  };\n  \n  return typeMap[normalized] || normalized;\n}\n\n// Helper function to parse price\nfunction parsePrice(price) {\n  if (!price) return null;\n  \n  // Remove currency symbols, commas, and whitespace\n  const cleaned = price.toString().replace(/[$,\\s]/g, '');\n  const parsed = parseFloat(cleaned);\n  \n  return isNaN(parsed) ? null : parsed;\n}\n\n// Helper function to parse date\nfunction parseDate(dateStr) {\n  if (!dateStr) return null;\n  \n  try {\n    // Handle various date formats (YYYY-MM, YYYY/MM, etc.)\n    const cleaned = dateStr.toString().trim();\n    const date = new Date(cleaned);\n    \n    if (isNaN(date.getTime())) return null;\n    return date.toISOString();\n  } catch (e) {\n    return null;\n  }\n}\n\n// Helper function to parse floor area\nfunction parseFloorArea(area) {\n  if (!area) return null;\n  \n  const cleaned = area.toString().replace(/[^0-9.]/g, '');\n  const parsed = parseFloat(cleaned);\n  \n  return isNaN(parsed) ? null : parsed;\n}\n\n// Process each item\nfor (const item of items) {\n  const data = item.json;\n  \n  // Skip if data is not an object\n  if (typeof data !== 'object' || data === null) continue;\n  \n  // Extract and clean fields\n  const month = data.month || data.Month || data.MONTH;\n  const town = normalizeTown(data.town || data.Town || data.TOWN);\n  const flatType = standardizeFlatType(data.flat_type || data.flatType || data.FlatType || data.flat_model);\n  const block = data.block || data.Block || data.BLOCK;\n  const streetName = data.street_name || data.streetName || data.StreetName;\n  const storeyRange = data.storey_range || data.storeyRange || data.StoreyRange;\n  const floorArea = parseFloorArea(data.floor_area_sqm || data.floorArea || data.FloorArea);\n  const flatModel = data.flat_model || data.flatModel || data.FlatModel;\n  const leaseCommenceDate = data.lease_commence_date || data.leaseCommenceDate || data.LeaseCommenceDate;\n  const remainingLease = data.remaining_lease || data.remainingLease || data.RemainingLease;\n  const resalePrice = parsePrice(data.resale_price || data.resalePrice || data.ResalePrice || data.price);\n  \n  // Validate required fields\n  if (!month || !town || !flatType || !resalePrice) {\n    continue; // Skip invalid records\n  }\n  \n  // Additional validation\n  if (resalePrice <= 0 || resalePrice > 2000000) continue; // Unrealistic prices\n  if (floorArea && (floorArea < 20 || floorArea > 300)) continue; // Unrealistic floor areas\n  \n  // Create unique identifier to detect duplicates\n  const recordId = `${month}_${town}_${flatType}_${block}_${streetName}_${resalePrice}`;\n  \n  if (seenRecords.has(recordId)) {\n    continue; // Skip duplicate\n  }\n  \n  seenRecords.add(recordId);\n  \n  // Create cleaned record\n  const cleanedRecord = {\n    month: parseDate(month),\n    town: town,\n    flat_type: flatType,\n    block: block ? block.toString().trim() : null,\n    street_name: streetName ? streetName.toString().trim() : null,\n    storey_range: storeyRange ? storeyRange.toString().trim() : null,\n    floor_area_sqm: floorArea,\n    flat_model: flatModel ? flatModel.toString().trim() : null,\n    lease_commence_date: leaseCommenceDate ? parseInt(leaseCommenceDate) : null,\n    remaining_lease: remainingLease ? remainingLease.toString().trim() : null,\n    resale_price: resalePrice,\n    // Add derived fields\n    year: month ? new Date(month).getFullYear() : null,\n    price_per_sqm: floorArea && resalePrice ? Math.round(resalePrice / floorArea) : null\n  };\n  \n  cleanedData.push({ json: cleanedRecord });\n}\n\nconsole.log(`Data Cleaning Summary:`);\nconsole.log(`- Input records: ${items.length}`);\nconsole.log(`- Cleaned records: ${cleanedData.length}`);\nconsole.log(`- Duplicates removed: ${items.length - cleanedData.length - (items.length - seenRecords.size)}`);\nconsole.log(`- Invalid records filtered: ${items.length - cleanedData.length}`);\n\nif (cleanedData.length === 0) {\n  throw new Error('No valid records after cleaning. Please check the input data format.');\n}\n\nreturn cleanedData;"
      },
      "typeVersion": 2
    },
    {
      "id": "87773176-547d-493c-9cce-d1713ea24a4d",
      "name": "Statistical Pattern Mining",
      "type": "n8n-nodes-base.code",
      "position": [
        688,
        96
      ],
      "parameters": {
        "jsCode": "// Statistical Pattern Mining for HDB Flat Price Data\n// This code performs comprehensive statistical analysis on the cleaned HDB data\n\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  return [];\n}\n\n// Helper function to calculate statistical measures\nfunction calculateStats(values) {\n  if (!values || values.length === 0) return null;\n  \n  const sorted = values.slice().sort((a, b) => a - b);\n  const n = sorted.length;\n  \n  // Mean\n  const mean = values.reduce((sum, val) => sum + val, 0) / n;\n  \n  // Median\n  const median = n % 2 === 0 \n    ? (sorted[n/2 - 1] + sorted[n/2]) / 2 \n    : sorted[Math.floor(n/2)];\n  \n  // Standard Deviation\n  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;\n  const stdDev = Math.sqrt(variance);\n  \n  // Quartiles\n  const q1Index = Math.floor(n * 0.25);\n  const q3Index = Math.floor(n * 0.75);\n  const q1 = sorted[q1Index];\n  const q3 = sorted[q3Index];\n  \n  return {\n    mean: Math.round(mean * 100) / 100,\n    median: Math.round(median * 100) / 100,\n    stdDev: Math.round(stdDev * 100) / 100,\n    q1: Math.round(q1 * 100) / 100,\n    q3: Math.round(q3 * 100) / 100,\n    min: sorted[0],\n    max: sorted[n - 1],\n    count: n\n  };\n}\n\n// Group data by flat type and town\nconst groupedData = {};\nconst timeSeriesData = {};\n\nitems.forEach(item => {\n  const data = item.json;\n  const flatType = data.flat_type || 'Unknown';\n  const town = data.town || 'Unknown';\n  const price = parseFloat(data.resale_price);\n  const floorLevel = parseFloat(data.floor_area_sqm) || 0;\n  const leaseRemaining = parseFloat(data.remaining_lease_years) || 0;\n  const flatSize = parseFloat(data.floor_area_sqm) || 0;\n  const year = data.year || new Date(data.month).getFullYear();\n  const month = data.month;\n  \n  // Group by flat type and town\n  const key = `${flatType}_${town}`;\n  if (!groupedData[key]) {\n    groupedData[key] = {\n      flatType,\n      town,\n      prices: [],\n      floorLevels: [],\n      leaseRemaining: [],\n      flatSizes: []\n    };\n  }\n  \n  groupedData[key].prices.push(price);\n  groupedData[key].floorLevels.push(floorLevel);\n  groupedData[key].leaseRemaining.push(leaseRemaining);\n  groupedData[key].flatSizes.push(flatSize);\n  \n  // Time series grouping\n  if (!timeSeriesData[year]) {\n    timeSeriesData[year] = { prices: [], months: {} };\n  }\n  timeSeriesData[year].prices.push(price);\n  \n  if (month) {\n    const monthKey = month.substring(0, 7); // YYYY-MM\n    if (!timeSeriesData[year].months[monthKey]) {\n      timeSeriesData[year].months[monthKey] = [];\n    }\n    timeSeriesData[year].months[monthKey].push(price);\n  }\n});\n\n// Calculate statistics by flat type and town\nconst statisticalInsights = [];\n\nfor (const [key, data] of Object.entries(groupedData)) {\n  const priceStats = calculateStats(data.prices);\n  const floorStats = calculateStats(data.floorLevels);\n  const leaseStats = calculateStats(data.leaseRemaining);\n  const sizeStats = calculateStats(data.flatSizes);\n  \n  // Calculate correlations (simplified Pearson correlation)\n  function correlation(x, y) {\n    if (x.length !== y.length || x.length === 0) return 0;\n    const n = x.length;\n    const meanX = x.reduce((a, b) => a + b, 0) / n;\n    const meanY = y.reduce((a, b) => a + b, 0) / n;\n    \n    let numerator = 0;\n    let denomX = 0;\n    let denomY = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      denomX += dx * dx;\n      denomY += dy * dy;\n    }\n    \n    if (denomX === 0 || denomY === 0) return 0;\n    return numerator / Math.sqrt(denomX * denomY);\n  }\n  \n  const priceFloorCorr = correlation(data.prices, data.floorLevels);\n  const priceLeaseCorr = correlation(data.prices, data.leaseRemaining);\n  const priceSizeCorr = correlation(data.prices, data.flatSizes);\n  \n  statisticalInsights.push({\n    flatType: data.flatType,\n    town: data.town,\n    priceStatistics: priceStats,\n    floorLevelStats: floorStats,\n    leaseRemainingStats: leaseStats,\n    flatSizeStats: sizeStats,\n    correlations: {\n      priceVsFloorLevel: Math.round(priceFloorCorr * 1000) / 1000,\n      priceVsLeaseRemaining: Math.round(priceLeaseCorr * 1000) / 1000,\n      priceVsFlatSize: Math.round(priceSizeCorr * 1000) / 1000\n    }\n  });\n}\n\n// Calculate year-over-year growth rates\nconst years = Object.keys(timeSeriesData).sort();\nconst yoyGrowth = [];\n\nfor (let i = 1; i < years.length; i++) {\n  const prevYear = years[i - 1];\n  const currYear = years[i];\n  const prevAvg = timeSeriesData[prevYear].prices.reduce((a, b) => a + b, 0) / timeSeriesData[prevYear].prices.length;\n  const currAvg = timeSeriesData[currYear].prices.reduce((a, b) => a + b, 0) / timeSeriesData[currYear].prices.length;\n  const growthRate = ((currAvg - prevAvg) / prevAvg) * 100;\n  \n  yoyGrowth.push({\n    fromYear: prevYear,\n    toYear: currYear,\n    previousAvgPrice: Math.round(prevAvg * 100) / 100,\n    currentAvgPrice: Math.round(currAvg * 100) / 100,\n    growthRate: Math.round(growthRate * 100) / 100\n  });\n}\n\n// Detect seasonal patterns (monthly averages)\nconst seasonalPatterns = {};\nfor (const [year, data] of Object.entries(timeSeriesData)) {\n  for (const [month, prices] of Object.entries(data.months)) {\n    const monthNum = month.substring(5, 7);\n    if (!seasonalPatterns[monthNum]) {\n      seasonalPatterns[monthNum] = [];\n    }\n    const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;\n    seasonalPatterns[monthNum].push(avgPrice);\n  }\n}\n\nconst seasonalInsights = [];\nfor (const [month, prices] of Object.entries(seasonalPatterns)) {\n  const stats = calculateStats(prices);\n  seasonalInsights.push({\n    month: month,\n    avgPrice: stats.mean,\n    priceRange: { min: stats.min, max: stats.max },\n    volatility: stats.stdDev\n  });\n}\n\n// Return comprehensive statistical insights\nreturn [{\n  json: {\n    statisticalPatterns: {\n      byFlatTypeAndTown: statisticalInsights,\n      yearOverYearGrowth: yoyGrowth,\n      seasonalPatterns: seasonalInsights.sort((a, b) => a.month.localeCompare(b.month)),\n      overallTrends: {\n        totalRecordsAnalyzed: items.length,\n        yearsAnalyzed: years,\n        averageGrowthRate: yoyGrowth.length > 0 \n          ? Math.round((yoyGrowth.reduce((sum, g) => sum + g.growthRate, 0) / yoyGrowth.length) * 100) / 100 \n          : 0\n      }\n    },\n    analysisTimestamp: new Date().toISOString()\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "e873f7f2-1c48-491a-9b9d-fb70800670a5",
      "name": "Time Series Analysis",
      "type": "n8n-nodes-base.code",
      "position": [
        688,
        288
      ],
      "parameters": {
        "jsCode": "// Time Series Analysis for HDB Flat Prices\n// Calculates moving averages, momentum indicators, trends, cycles, volatility, and exponential smoothing\n\nconst items = $input.all();\n\n// Helper function to calculate moving average\nfunction calculateMovingAverage(data, period) {\n  const result = [];\n  for (let i = 0; i < data.length; i++) {\n    if (i < period - 1) {\n      result.push(null);\n    } else {\n      const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\n      result.push(sum / period);\n    }\n  }\n  return result;\n}\n\n// Helper function to calculate exponential moving average\nfunction calculateEMA(data, period) {\n  const k = 2 / (period + 1);\n  const ema = [data[0]];\n  \n  for (let i = 1; i < data.length; i++) {\n    ema.push(data[i] * k + ema[i - 1] * (1 - k));\n  }\n  return ema;\n}\n\n// Helper function to calculate standard deviation\nfunction calculateStdDev(data) {\n  const mean = data.reduce((a, b) => a + b, 0) / data.length;\n  const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;\n  return Math.sqrt(variance);\n}\n\n// Sort items by date\nconst sortedItems = items.sort((a, b) => {\n  const dateA = new Date(a.json.month || a.json.date || a.json.year);\n  const dateB = new Date(b.json.month || b.json.date || b.json.year);\n  return dateA - dateB;\n});\n\n// Extract price data\nconst prices = sortedItems.map(item => parseFloat(item.json.resale_price || item.json.price || 0));\n\n// Calculate moving averages\nconst ma3 = calculateMovingAverage(prices, 3);\nconst ma6 = calculateMovingAverage(prices, 6);\nconst ma12 = calculateMovingAverage(prices, 12);\n\n// Calculate exponential moving averages\nconst ema3 = calculateEMA(prices, 3);\nconst ema6 = calculateEMA(prices, 6);\nconst ema12 = calculateEMA(prices, 12);\n\n// Calculate momentum indicators\nconst momentum = prices.map((price, i) => {\n  if (i < 3) return null;\n  return price - prices[i - 3];\n});\n\n// Calculate rate of change (ROC)\nconst roc = prices.map((price, i) => {\n  if (i < 12 || prices[i - 12] === 0) return null;\n  return ((price - prices[i - 12]) / prices[i - 12]) * 100;\n});\n\n// Identify trend direction\nconst recentPrices = prices.slice(-12);\nconst firstHalf = recentPrices.slice(0, 6).reduce((a, b) => a + b, 0) / 6;\nconst secondHalf = recentPrices.slice(6).reduce((a, b) => a + b, 0) / 6;\nconst trendDirection = secondHalf > firstHalf ? 'upward' : secondHalf < firstHalf ? 'downward' : 'stable';\nconst trendStrength = Math.abs(((secondHalf - firstHalf) / firstHalf) * 100);\n\n// Calculate volatility metrics\nconst returns = prices.slice(1).map((price, i) => (price - prices[i]) / prices[i]);\nconst volatility = calculateStdDev(returns) * 100;\n\n// Calculate rolling volatility (12-month window)\nconst rollingVolatility = [];\nfor (let i = 11; i < prices.length; i++) {\n  const windowPrices = prices.slice(i - 11, i + 1);\n  const windowReturns = windowPrices.slice(1).map((price, j) => (price - windowPrices[j]) / windowPrices[j]);\n  rollingVolatility.push(calculateStdDev(windowReturns) * 100);\n}\n\n// Detect cyclical patterns (simplified seasonal decomposition)\nconst monthlyAverages = {};\nsortedItems.forEach(item => {\n  const date = new Date(item.json.month || item.json.date || item.json.year);\n  const month = date.getMonth();\n  if (!monthlyAverages[month]) {\n    monthlyAverages[month] = [];\n  }\n  monthlyAverages[month].push(parseFloat(item.json.resale_price || item.json.price || 0));\n});\n\nconst seasonalFactors = {};\nfor (let month in monthlyAverages) {\n  seasonalFactors[month] = monthlyAverages[month].reduce((a, b) => a + b, 0) / monthlyAverages[month].length;\n}\n\nconst overallMean = prices.reduce((a, b) => a + b, 0) / prices.length;\nconst seasonalIndices = {};\nfor (let month in seasonalFactors) {\n  seasonalIndices[month] = (seasonalFactors[month] / overallMean) * 100;\n}\n\n// Prepare output with time series features\nconst timeSeriesFeatures = {\n  moving_averages: {\n    ma_3_month: ma3.filter(v => v !== null).slice(-1)[0] || null,\n    ma_6_month: ma6.filter(v => v !== null).slice(-1)[0] || null,\n    ma_12_month: ma12.filter(v => v !== null).slice(-1)[0] || null\n  },\n  exponential_moving_averages: {\n    ema_3_month: ema3.slice(-1)[0] || null,\n    ema_6_month: ema6.slice(-1)[0] || null,\n    ema_12_month: ema12.slice(-1)[0] || null\n  },\n  momentum_indicators: {\n    momentum_3_month: momentum.filter(v => v !== null).slice(-1)[0] || null,\n    rate_of_change_12_month: roc.filter(v => v !== null).slice(-1)[0] || null\n  },\n  trend_analysis: {\n    direction: trendDirection,\n    strength_percentage: trendStrength.toFixed(2),\n    current_price: prices.slice(-1)[0],\n    price_change_12_month: prices.length >= 12 ? prices.slice(-1)[0] - prices[prices.length - 12] : null\n  },\n  volatility_metrics: {\n    overall_volatility_percentage: volatility.toFixed(2),\n    recent_volatility_12_month: rollingVolatility.slice(-1)[0]?.toFixed(2) || null,\n    price_range: {\n      min: Math.min(...prices),\n      max: Math.max(...prices),\n      range: Math.max(...prices) - Math.min(...prices)\n    }\n  },\n  seasonal_patterns: {\n    seasonal_indices: seasonalIndices,\n    strongest_month: Object.keys(seasonalIndices).reduce((a, b) => seasonalIndices[a] > seasonalIndices[b] ? a : b),\n    weakest_month: Object.keys(seasonalIndices).reduce((a, b) => seasonalIndices[a] < seasonalIndices[b] ? a : b)\n  },\n  data_summary: {\n    total_observations: prices.length,\n    date_range: {\n      start: sortedItems[0].json.month || sortedItems[0].json.date || sortedItems[0].json.year,\n      end: sortedItems[sortedItems.length - 1].json.month || sortedItems[sortedItems.length - 1].json.date || sortedItems[sortedItems.length - 1].json.year\n    },\n    mean_price: overallMean.toFixed(2)\n  }\n};\n\nreturn [{ json: timeSeriesFeatures }];"
      },
      "typeVersion": 2
    },
    {
      "id": "c03ff069-3e4c-4ed1-9a5d-1544d06dc3bd",
      "name": "Aggregate Statistical Features",
      "type": "n8n-nodes-base.aggregate",
      "position": [
        912,
        192
      ],
      "parameters": {
        "options": {},
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "json"
      },
      "typeVersion": 1
    },
    {
      "id": "1b6af081-8b06-4196-ae79-79efffe84f54",
      "name": "AI Forecasting Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        1232,
        80
      ],
      "parameters": {
        "text": "You are an expert real estate data scientist specializing in HDB flat price forecasting. Analyze the provided statistical patterns, time series features, and historical trends. Use the statistical_forecasting tool to generate probabilistic price predictions for the next 12 months. Consider seasonal patterns, market trends, location factors, and flat characteristics. Provide forecasts with confidence intervals for different flat types and towns.",
        "options": {},
        "promptType": "define",
        "hasOutputParser": true
      },
      "typeVersion": 3
    },
    {
      "id": "cfcbc04c-4f14-4473-b4e6-8c3d9a9389b3",
      "name": "OpenAI GPT-4 Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        1104,
        304
      ],
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "id",
          "value": "gpt-4o"
        },
        "options": {}
      },
      "credentials": {
        "openAiApi": {
          "id": "mv2ECvRtbAK63G2g",
          "name": "OpenAi account"
        }
      },
      "typeVersion": 1.2
    },
    {
      "id": "b31ccf03-1c0e-49e4-9419-a46f4767faf3",
      "name": "Statistical Forecasting Tool",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "position": [
        1232,
        304
      ],
      "parameters": {
        "jsCode": "// Advanced Statistical Forecasting Tool for HDB Price Data\n// Implements linear regression, exponential smoothing, and Monte Carlo simulation\n\n// Parse input query - expecting JSON string with historical price data\nlet inputData;\ntry {\n  inputData = typeof query === 'string' ? JSON.parse(query) : query;\n} catch (e) {\n  return JSON.stringify({ error: 'Invalid input format. Expected JSON with historical price data.' });\n}\n\nconst prices = inputData.prices || [];\nconst dates = inputData.dates || [];\n\nif (prices.length < 3) {\n  return JSON.stringify({ error: 'Insufficient data points. Need at least 3 historical data points.' });\n}\n\n// Linear Regression Function\nfunction linearRegression(x, y) {\n  const n = x.length;\n  const sumX = x.reduce((a, b) => a + b, 0);\n  const sumY = y.reduce((a, b) => a + b, 0);\n  const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n  const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n  \n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  \n  return { slope, intercept };\n}\n\n// Calculate Mean Absolute Percentage Error\nfunction calculateMAPE(actual, predicted) {\n  const n = actual.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    sum += Math.abs((actual[i] - predicted[i]) / actual[i]);\n  }\n  return (sum / n) * 100;\n}\n\n// Exponential Smoothing\nfunction exponentialSmoothing(data, alpha = 0.3) {\n  const smoothed = [data[0]];\n  for (let i = 1; i < data.length; i++) {\n    smoothed.push(alpha * data[i] + (1 - alpha) * smoothed[i - 1]);\n  }\n  return smoothed;\n}\n\n// Monte Carlo Simulation for confidence intervals\nfunction monteCarloSimulation(basePrice, volatility, months, simulations = 1000) {\n  const results = [];\n  \n  for (let month = 1; month <= months; month++) {\n    const monthResults = [];\n    \n    for (let sim = 0; sim < simulations; sim++) {\n      // Random walk with drift\n      const randomShock = (Math.random() - 0.5) * 2 * volatility;\n      const price = basePrice * (1 + randomShock * Math.sqrt(month));\n      monthResults.push(price);\n    }\n    \n    monthResults.sort((a, b) => a - b);\n    results.push({\n      month: month,\n      mean: monthResults.reduce((a, b) => a + b, 0) / simulations,\n      lower: monthResults[Math.floor(simulations * 0.05)],\n      upper: monthResults[Math.floor(simulations * 0.95)],\n      median: monthResults[Math.floor(simulations * 0.5)]\n    });\n  }\n  \n  return results;\n}\n\n// Main forecasting logic\nconst timeIndices = prices.map((_, i) => i);\nconst { slope, intercept } = linearRegression(timeIndices, prices);\n\n// Calculate volatility (standard deviation of returns)\nconst returns = [];\nfor (let i = 1; i < prices.length; i++) {\n  returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);\n}\nconst meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\nconst variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length;\nconst volatility = Math.sqrt(variance);\n\n// Apply exponential smoothing\nconst smoothedPrices = exponentialSmoothing(prices);\n\n// Generate predictions for next 12 months\nconst predictions = [];\nconst lastIndex = prices.length - 1;\nconst lastPrice = prices[lastIndex];\n\nfor (let month = 1; month <= 12; month++) {\n  const futureIndex = lastIndex + month;\n  const linearPrediction = slope * futureIndex + intercept;\n  const trendAdjusted = linearPrediction * (1 + meanReturn * month);\n  \n  predictions.push({\n    month: month,\n    predicted_price: Math.round(trendAdjusted),\n    linear_trend: Math.round(linearPrediction)\n  });\n}\n\n// Monte Carlo simulation for confidence intervals\nconst mcResults = monteCarloSimulation(lastPrice, volatility, 12);\n\n// Combine predictions with confidence intervals\nconst forecast = predictions.map((pred, i) => ({\n  month: pred.month,\n  predicted_price: pred.predicted_price,\n  lower_bound: Math.round(mcResults[i].lower),\n  upper_bound: Math.round(mcResults[i].upper),\n  confidence_level: '90%'\n}));\n\n// Calculate fitted values for accuracy metrics\nconst fittedValues = timeIndices.map(i => slope * i + intercept);\nconst mape = calculateMAPE(prices, fittedValues);\n\n// Prepare output\nconst output = {\n  forecast_12_months: forecast,\n  model_metrics: {\n    slope: slope.toFixed(4),\n    intercept: intercept.toFixed(2),\n    volatility: (volatility * 100).toFixed(2) + '%',\n    mape: mape.toFixed(2) + '%',\n    mean_return: (meanReturn * 100).toFixed(2) + '%'\n  },\n  summary: `Forecasted ${forecast.length} months ahead. Average predicted price: $${Math.round(forecast.reduce((sum, f) => sum + f.predicted_price, 0) / forecast.length)}. Model accuracy (MAPE): ${mape.toFixed(2)}%`\n};\n\nreturn JSON.stringify(output, null, 2);",
        "description": "Performs advanced statistical forecasting using linear regression, exponential smoothing, and trend analysis on HDB price data"
      },
      "typeVersion": 1.3
    },
    {
      "id": "1c0af53c-7990-4d68-9878-8ad6e76ba4a1",
      "name": "Calculator Tool",
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "position": [
        1360,
        304
      ],
      "parameters": {},
      "typeVersion": 1
    },
    {
      "id": "c35bd2a7-c691-4c94-8f35-f23d51d7b18b",
      "name": "Structured Forecast Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        1488,
        304
      ],
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"flat_type\": {\n      \"type\": \"string\",\n      \"description\": \"Type of HDB flat (e.g., 3 ROOM, 4 ROOM, 5 ROOM, EXECUTIVE)\"\n    },\n    \"town\": {\n      \"type\": \"string\",\n      \"description\": \"Town or location of the HDB flat\"\n    },\n    \"forecast_month\": {\n      \"type\": \"string\",\n      \"description\": \"Month for which the forecast is made (e.g., 2024-01)\"\n    },\n    \"predicted_price\": {\n      \"type\": \"number\",\n      \"description\": \"Predicted resale price in SGD\"\n    },\n    \"lower_bound\": {\n      \"type\": \"number\",\n      \"description\": \"Lower bound of the price prediction confidence interval\"\n    },\n    \"upper_bound\": {\n      \"type\": \"number\",\n      \"description\": \"Upper bound of the price prediction confidence interval\"\n    },\n    \"confidence_level\": {\n      \"type\": \"number\",\n      \"description\": \"Confidence level of the prediction (0-1 scale)\"\n    },\n    \"trend_direction\": {\n      \"type\": \"string\",\n      \"description\": \"Direction of price trend (e.g., increasing, decreasing, stable)\"\n    },\n    \"key_factors\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"description\": \"Key factors influencing the forecast\"\n    }\n  },\n  \"required\": [\"flat_type\", \"town\", \"forecast_month\", \"predicted_price\", \"lower_bound\", \"upper_bound\", \"confidence_level\", \"trend_direction\", \"key_factors\"]\n}"
      },
      "typeVersion": 1.3
    },
    {
      "id": "24bf4ad3-a1cb-447a-8438-fab20e6392c3",
      "name": "Format Forecast Results",
      "type": "n8n-nodes-base.set",
      "position": [
        1728,
        80
      ],
      "parameters": {
        "options": {},
        "assignments": {
          "assignments": [
            {
              "id": "id-1",
              "name": "forecast_date",
              "type": "string",
              "value": "={{ $now.toISO() }}"
            },
            {
              "id": "id-2",
              "name": "model_version",
              "type": "string",
              "value": "v1.0"
            },
            {
              "id": "id-3",
              "name": "data_source",
              "type": "string",
              "value": "Singapore HDB Data.gov.sg"
            }
          ]
        },
        "includeOtherFields": true
      },
      "typeVersion": 3.4
    },
    {
      "id": "309d0df2-c531-40ae-ab2b-5dbf09969cb1",
      "name": "Save to Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "position": [
        1920,
        80
      ],
      "parameters": {
        "columns": {
          "value": {
            "town": "={{ $json.town }}",
            "flat_type": "={{ $json.flat_type }}",
            "lower_bound": "={{ $json.lower_bound }}",
            "upper_bound": "={{ $json.upper_bound }}",
            "forecast_date": "={{ $json.forecast_date }}",
            "model_version": "={{ $json.model_version }}",
            "forecast_month": "={{ $json.forecast_month }}",
            "predicted_price": "={{ $json.predicted_price }}",
            "trend_direction": "={{ $json.trend_direction }}",
            "confidence_level": "={{ $json.confidence_level }}"
          },
          "schema": [
            {
              "id": "flat_type",
              "required": false,
              "displayName": "flat_type",
              "defaultMatch": true,
              "canBeUsedToMatch": true
            },
            {
              "id": "town",
              "required": false,
              "displayName": "town",
              "defaultMatch": true,
              "canBeUsedToMatch": true
            },
            {
              "id": "forecast_month",
              "required": false,
              "displayName": "forecast_month",
              "defaultMatch": true,
              "canBeUsedToMatch": true
            },
            {
              "id": "predicted_price",
              "required": false,
              "displayName": "predicted_price",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "lower_bound",
              "required": false,
              "displayName": "lower_bound",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "upper_bound",
              "required": false,
              "displayName": "upper_bound",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "confidence_level",
              "required": false,
              "displayName": "confidence_level",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "trend_direction",
              "required": false,
              "displayName": "trend_direction",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "forecast_date",
              "required": false,
              "displayName": "forecast_date",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            },
            {
              "id": "model_version",
              "required": false,
              "displayName": "model_version",
              "defaultMatch": false,
              "canBeUsedToMatch": false
            }
          ],
          "mappingMode": "defineBelow",
          "matchingColumns": [
            "flat_type",
            "town",
            "forecast_month"
          ]
        },
        "options": {},
        "operation": "appendOrUpdate",
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "HDB Price Forecasts"
        },
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "<__PLACEHOLDER_VALUE__Google Sheets Document ID__>"
        }
      },
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hQFe8XTqJEiHL03Z",
          "name": "Google Sheets account"
        }
      },
      "typeVersion": 4.7
    },
    {
      "id": "73fe488b-4fac-4105-94da-0a7c3bd51ee0",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -496,
        -96
      ],
      "parameters": {
        "color": 7,
        "width": 864,
        "height": 848,
        "content": "## 1. Data Collection Layer\n\nFetches current-year HDB data with 3 years of historical records in parallel.\n**Why:** Eliminates manual gathering and provides full historical context for trend analysis."
      },
      "typeVersion": 1
    },
    {
      "id": "6da52b14-c464-4655-bcb3-5682edea4ba5",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        384,
        -96
      ],
      "parameters": {
        "color": 7,
        "width": 224,
        "height": 592,
        "content": "## 2. Data Consolidation & Cleaning\n\nMerges datasets and normalizes values.\n**Why:** Prevents fragmented data from corrupting analysis; clean, unified data is essential for accurate forecasts."
      },
      "typeVersion": 1
    },
    {
      "id": "0d843aeb-9906-414f-8f80-06e1a9a4d231",
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        624,
        -96
      ],
      "parameters": {
        "color": 7,
        "width": 400,
        "height": 592,
        "content": "## 3. Pattern & Trend Analysis\n\nRuns statistical pattern mining and time series analysis on consolidated data.\n**Why:** Captures recurring patterns and long-term trends; dual approach avoids missing key signals."
      },
      "typeVersion": 1
    },
    {
      "id": "70857d8d-4dcd-4a21-8dba-32fd226af0f6",
      "name": "Sticky Note3",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1056,
        -96
      ],
      "parameters": {
        "color": 7,
        "width": 592,
        "height": 592,
        "content": "## 4. AI Forecasting Agent (Intelligence Hub)\n\nProcesses features via GPT-4 with statistical forecasting and calculator tools.\n**Why:** Synthesizes multiple perspectives into actionable, validated predictions."
      },
      "typeVersion": 1
    },
    {
      "id": "f3e96eed-ef12-49fe-b3b2-a9f8f1ef6cc0",
      "name": "Sticky Note4",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1680,
        -96
      ],
      "parameters": {
        "color": 7,
        "width": 448,
        "height": 384,
        "content": "## 5. Output & Storage\n\nFormats predictions and saves to Google Sheets.\n**Why:** Provides immediate access with an audit trail, no manual export needed."
      },
      "typeVersion": 1
    },
    {
      "id": "c5163331-6a18-4a32-8c9b-5ab6a780c3b9",
      "name": "Sticky Note5",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -496,
        -384
      ],
      "parameters": {
        "width": 592,
        "height": 256,
        "content": "## How It Works\nThe workflow runs on a monthly trigger to collect both current-year and multi-year historical HDB data. Once fetched, all datasets are merged with aligned fields to produce a unified table. The system then applies cleaning and normalization rules to ensure consistent scales and comparable values. After preprocessing, it performs pattern mining, anomaly checks, and time-series analysis to extract trends and forecast signals. An AI agent, integrating OpenAI GPT-4, statistical tools, and calculator nodes, synthesizes these results into coherent insights. The final predictions are formatted and automatically written to Google Sheets for reporting and downstream use.\n\n"
      },
      "typeVersion": 1
    },
    {
      "id": "88ef0bfa-84a8-49cb-a584-b7362e8b1fb1",
      "name": "Sticky Note6",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        128,
        -384
      ],
      "parameters": {
        "color": 2,
        "width": 624,
        "height": 256,
        "content": "## Setup Steps\n1) Configure fetch nodes to pull current-year HDB data and three years of historical records.\n2) Align and map column names across all datasets.\n3) Set normalization and standardization parameters in the cleaning node.\n4) Add your OpenAI API key (GPT-4) and link the model, forecasting tool, and calculator nodes.\n5) Authorize Google Sheets and configure sheet and cell mappings for automated export.\n \n"
      },
      "typeVersion": 1
    },
    {
      "id": "856eb6ed-d34d-4a25-b2f6-7536d2f51e14",
      "name": "Sticky Note7",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        784,
        -384
      ],
      "parameters": {
        "color": 3,
        "width": 496,
        "height": 144,
        "content": "## Prerequisites\n- Historical data source with API access (3+ years of records)\n- OpenAI API key for GPT-4 model\n- Google Sheets account with API credentials\n- Basic understanding of time series data\n"
      },
      "typeVersion": 1
    },
    {
      "id": "a4b2ea8f-8349-477c-b204-ae061ac371d6",
      "name": "Sticky Note8",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1312,
        -384
      ],
      "parameters": {
        "color": 4,
        "width": 256,
        "height": 224,
        "content": "\n## Use Cases\n**Real Estate:** Forecast property prices using multi-year historical HDB/market data with confidence intervals\n**Finance:** Predict market trends by aggregating years of transaction or pricing records\n"
      },
      "typeVersion": 1
    },
    {
      "id": "4be19165-e2d7-4a95-903e-7fbd55d71995",
      "name": "Sticky Note9",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1600,
        -384
      ],
      "parameters": {
        "color": 6,
        "width": 464,
        "height": 256,
        "content": "\n## Customization\n**Data Source:** Replace HDB/fetch nodes with stock prices, sensor data, sales records, or any historical dataset\n**Analysis Window:** Adjust years fetched (2-5 years) based on data availability and prediction horizon\n\n\n## Benefits\n**Automation:** Monthly scheduling eliminates manual data gathering and analysis\n "
      },
      "typeVersion": 1
    }
  ],
  "active": false,
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "3ea99275-1c33-4516-80c8-eb3bcd4fe06c",
  "connections": {
    "Calculator Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Forecasting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI GPT-4 Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Forecasting Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Forecasting Agent": {
      "main": [
        [
          {
            "node": "Format Forecast Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Time Series Analysis": {
      "main": [
        [
          {
            "node": "Aggregate Statistical Features",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Workflow Configuration": {
      "main": [
        [
          {
            "node": "Fetch Current Year HDB Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Historical Data Year 1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Historical Data Year 2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Historical Data Year 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Forecast Results": {
      "main": [
        [
          {
            "node": "Save to Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Historical Data": {
      "main": [
        [
          {
            "node": "Data Cleaning and Normalization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Statistical Pattern Mining": {
      "main": [
        [
          {
            "node": "Aggregate Statistical Features",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Year HDB Data": {
      "main": [
        [
          {
            "node": "Merge All Historical Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Historical Data Year 1": {
      "main": [
        [
          {
            "node": "Merge All Historical Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Fetch Historical Data Year 2": {
      "main": [
        [
          {
            "node": "Merge All Historical Data",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Fetch Historical Data Year 3": {
      "main": [
        [
          {
            "node": "Merge All Historical Data",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Statistical Forecasting Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Forecasting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Statistical Features": {
      "main": [
        [
          {
            "node": "AI Forecasting Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Cleaning and Normalization": {
      "main": [
        [
          {
            "node": "Statistical Pattern Mining",
            "type": "main",
            "index": 0
          },
          {
            "node": "Time Series Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Monthly Data Collection Trigger": {
      "main": [
        [
          {
            "node": "Workflow Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Forecast Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Forecasting Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    }
  }
}